/* This file was generated by the Amherst version of SableCC */

package minijava.Typechecker;

import java.util.LinkedList;
import java.util.List;

import minijava.Frame.Access;
import minijava.Type.ArrayType;
import minijava.Type.Type;
import minijava.node.*;
import minijava.Temp.Label;
import minijava.Temp.Temp;
import minijava.Translate.*;
import minijava.Tree.*;

public class Phase2
{
	private Typechecker typechecker;
	

	public Phase2(Typechecker t){
		this.typechecker=t;
	}

    void process(Node n) {
    	 throw new RuntimeException(this.getClass() + ": no process method available for " 
	     + n.getClass());
    }

    ///////////////////////////////////////////////////////////////
    void process(Start n) {
         process(n.getPProgram());
    }

    ///////////////////////////////////////////////////////////////
    void process(PProgram n) {
        process((AProgram)n);
    }

    ///////////////////////////////////////////////////////////////
    void process(AProgram n) {
        n.getPublic();				// yields TPublic
        n.getClasstok();				// yields TClasstok
        n.getId();				// yields TId
        n.getLbrace();				// yields TLbrace
	for (PMaindecl p : n.getMaindecl())
	    process(p);				// process(PMaindecl)
        n.getRbrace();				// yields TRbrace
    }

    ///////////////////////////////////////////////////////////////
    void process(PMaindecl n) {
        if (n instanceof AVarMaindecl) process((AVarMaindecl)n);
	else if (n instanceof AMethodMaindecl) process((AMethodMaindecl)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PMaindecl)");
    }

    ///////////////////////////////////////////////////////////////
    void process(AVarMaindecl n) {
        process(n.getPrivacy());			// process(PPrivacy)
        n.getStatic();				// yields TStatic
        process(n.getType());			// process(PType)
        String name = n.getId().getText();				// yields TId
        Var var = typechecker.classVarMap.get(name);
        Label l =typechecker.machine.makeLabel("v");
        var.setLabel(l);
        n.getSemi();				// yields TSemi
    }

    ///////////////////////////////////////////////////////////////
    void process(AMethodMaindecl n) {
        process(n.getPrivacy());			// process(PPrivacy)
        n.getStatic();				// yields TStatic
        process(n.getType());
        
        String name = n.getId().getText();				// yields TId
        n.getLparen();				// yields TLparen
       
        typechecker.localSymbolTable.increaseScope();
        typechecker.setCurrentMethodName(name);
        
        List<Var> paramList=process(n.getParamlist());			// process(PParamlist)
        
        
        Method currentMethod=typechecker.currentMethod;

        
        currentMethod.makeFrame(typechecker.machine);
        
        List<Access> paramAccesses = typechecker.getParameterAccesses();

        for(int i=0; i<paramList.size(); i++){
        	Var v = paramList.get(i);
        	v.setAccess(paramAccesses.get(i));
        }
        
        n.getRparen();				// yields TRparen
        n.getLbrace();				// yields TLbrace
		
		
                
		Label exitLabel = typechecker.machine.makeLabel(name);
		currentMethod.setExitLabel(exitLabel);
		
		if (!typechecker.currentMethod.getReturnType().sameType(Type.voidType)){
			currentMethod.setHidden(); 
		}
		
		Stm block;				// yields TLbrace
		if(n.getStmt().size()>0){
		    block = process(n.getStmt().get(0));
		}else{
		    block = typechecker.noop();
		}
        for(int i = 1; i<n.getStmt().size(); i++) {
        	block = new SEQ(block, process(n.getStmt().get(i)));
        }
        
        Stm stmNode;
        if (typechecker.currentMethod.getReturnType().sameType(Type.voidType)){
        	stmNode = new LABEL(currentMethod.exitLabel);
        }
        else{
        	LABEL labelNode = new LABEL(currentMethod.exitLabel);
        	MOVE moveNode = new MOVE(new TEMP (currentMethod.frame.RV()), currentMethod.hidden.access.exp(new TEMP(typechecker.currentMethod.frame.FP())));
        	stmNode = new SEQ(labelNode, moveNode);
        	
        }
        
        Stm body = new SEQ(block, stmNode);
        currentMethod.setBody(body);
	    
        n.getRbrace();				// yields TRbrace
       
	    typechecker.localSymbolTable.decreaseScope();
    }

    ///////////////////////////////////////////////////////////////
    List<Var> process(PParamlist n) {
        if (n instanceof AListParamlist) return process((AListParamlist)n);
	else if (n instanceof AEmptyParamlist) return process((AEmptyParamlist)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PParamlist)");

    }

    ///////////////////////////////////////////////////////////////
    List<Var> process(AListParamlist n) {
    	List<Type> paramList = new LinkedList<Type>();
    	List<Var> varList = new LinkedList<Var>();
		String firstParam = n.getId().getText();
	    Type firstType = process(n.getType());
	    paramList.add(firstType);
	    Var v = new Var(firstParam, firstType);
	    varList.add(v);
	    typechecker.setParamTypes(firstType.toString());
	    typechecker.declareLocal(firstParam, v, n.getId());
	    for (PParam p : n.getParam()){
	    	Var var = process(p);
	    	varList.add(var);
	    	String name = var.name;				// process(PParam)
	    	Type type = var.type;
	    	paramList.add(type);
	    	typechecker.setParamTypes(type.toString());
	    	typechecker.declareLocal(name, var, n.getId());
	    }
        typechecker.setCurrentMethod();
    return varList;
    }

    ///////////////////////////////////////////////////////////////
    List<Var> process(AEmptyParamlist n) {
    	typechecker.setCurrentMethod();
    	return new LinkedList<Var>();
    }

    ///////////////////////////////////////////////////////////////
    Var process(PParam n) {
       return process((AParam)n);
    }

    ///////////////////////////////////////////////////////////////
    Var process(AParam n) {
        n.getComma();				// yields TComma
        Type nType=process(n.getType());			// process(PType)
        Var v = new Var(n.getId().getText(), nType);
        return v;				// yields TId
    }

    ///////////////////////////////////////////////////////////////
    void process(PPrivacy n) {
        if (n instanceof APublicPrivacy) process((APublicPrivacy)n);
	else if (n instanceof ABlankPrivacy) process((ABlankPrivacy)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PPrivacy)");

    }

    ///////////////////////////////////////////////////////////////
    void process(APublicPrivacy n) {
        n.getPublic();				// yields TPublic
    }

    ///////////////////////////////////////////////////////////////
    void process(ABlankPrivacy n) {

    }

    ///////////////////////////////////////////////////////////////
    Type process(PType n) {
        return process((AType)n);
    }

    ///////////////////////////////////////////////////////////////
    Type process(AType n) {
        Type nType = typechecker.getType(n.getId());  //n.getID() yields TId
	for (PEmptydim p : n.getEmptydim()){
		//TESTER CODE:  System.out.println("points to baseCase"+nType);  
		nType = typechecker.makeArrayType(nType, n.getId());
	    //process(p);				// process(PEmptydim)
		}
        return nType;    // remove when method is complete
    }

    ///////////////////////////////////////////////////////////////
    Stm process(PStmt n) {
        if (n instanceof AWhileStmt) return process((AWhileStmt)n);
	else if (n instanceof ADeclStmt) return process((ADeclStmt)n);
	else if (n instanceof ABlockStmt) return process((ABlockStmt)n);
	else if (n instanceof AIfStmt) return process((AIfStmt)n);
	else if (n instanceof AExprStmt) return process((AExprStmt)n);
	else if (n instanceof AReturnStmt) return process((AReturnStmt)n);
	else if (n instanceof APrintStmt) return process((APrintStmt)n);
	else if (n instanceof AEmptyStmt) return process((AEmptyStmt)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PStmt)");
    }

    ///////////////////////////////////////////////////////////////
    Stm process(AWhileStmt n) {
    	//System.out.println("in while statement");
		Label l1 = new Label();
		Label ltrue = new Label();
		Label lfalse = new Label();
	
	        Token t = n.getWhile();				// yields TWhile
	        n.getLparen();				// yields TLparen
		Stm s1 = new LABEL(l1);
	        ExprType expression = process(n.getExpr());			// process(PExpr)
	        if(!expression.getType().sameType(Type.booleanType))
	        	throw new TypecheckerException(n.getLparen(), "incompatible types: "+expression.getType()+" cannot be converted to boolean");
		Stm s2 = expression.expr.unCx(ltrue, lfalse);
	        n.getRparen();				// yields TRparen
	        typechecker.localSymbolTable.increaseScope();
		Stm s3= new LABEL(ltrue);
	        Stm s4 = process(n.getStmt());			// process(PStmt)
		Stm s5 = new JUMP(l1);
		Stm s6 = new LABEL(lfalse);
	        typechecker.localSymbolTable.decreaseScope();
        return typechecker.seq(s1, s2, s3, s4, s5, s6);
    }

    ///////////////////////////////////////////////////////////////
    Stm process(ADeclStmt n) {
    	//System.out.println("in ADeclStmt");
        Type nType = process(n.getType());			// process(PType)
        String s = n.getId().getText();
        Var v = new Var(s, nType);
        v.setAccess(typechecker.currentMethod);
        boolean declared =typechecker.declareLocal(s, v, n.getId());
        if(declared==false){
        	throw new TypecheckerException(n.getId(), "var already exists in local symbol table");
        }
        return typechecker.noop();
    }

    ///////////////////////////////////////////////////////////////
    Stm process(ABlockStmt n) {
    	//System.out.println("in ABlockStmt");
        n.getLbrace();
	Stm block;				// yields TLbrace
	if(n.getStmt().size()>0){
	    block = process(n.getStmt().get(0));
	}else{
	    block = typechecker.noop();
	}
        typechecker.localSymbolTable.increaseScope();
        for(int i = 1; i<n.getStmt().size(); i++) {
        	block = new SEQ(block, process(n.getStmt().get(i)));
        }
        typechecker.localSymbolTable.decreaseScope();
        n.getRbrace();			// yields TRbrace
        return block;
    }

    ///////////////////////////////////////////////////////////////
    Stm process(AIfStmt n) {
    	//System.out.println("in AIfStmt");
	Label ltrue = new Label();
	Label lfalse = new Label();
	Label finalLabel = new Label();
        n.getIf();				// yields TIf
        n.getLparen();				// yields TLparen
	typechecker.localSymbolTable.increaseScope();
        ExprType expression = process(n.getExpr());			// process(PExpr)
        if(!expression.getType().sameType(Type.booleanType))
        	throw new TypecheckerException(n.getLparen(), "incompatible types: "+expression.getType()+" cannot be converted to boolean");
	Stm s1 = expression.expr.unCx(ltrue, lfalse);
        n.getRparen();				// yields TRparen
	Stm s2 = new LABEL(ltrue);
        Stm s3 = process(n.getThenclause());			// process(PStmt)
	Stm s4 = new JUMP(finalLabel);
        typechecker.localSymbolTable.decreaseScope();
        n.getElse();				// yields TElse
        typechecker.localSymbolTable.increaseScope();
	Stm s5 = new LABEL(lfalse);
        Stm s6 = process(n.getElseclause());			// process(PStmt)
        typechecker.localSymbolTable.decreaseScope();
	Stm s7 = new LABEL(finalLabel);
        return typechecker.seq(s1, s2, s3, s4, s5, s6, s7);
    }

    
    ///////////////////////////////////////////////////////////////
    Stm process(AExprStmt n) {
    	//System.out.println("in AExprStmt");
        ExprType e = process(n.getExpr());			// process(PExpr)
	ESTM eStm= new ESTM(e.expr.unEx());
        n.getSemi();				// yields TSemi
        return eStm;
        
    }

    ///////////////////////////////////////////////////////////////
    Stm process(AReturnStmt n) {
    	//System.out.println("in AReturnStmt");
        n.getReturn();				// yields TReturn
        Type returnType = typechecker.currentMethod.getReturnType();
        if (n.getExpr() != null){
            ExprType exprType = process(n.getExpr());		// process(PExpr)
            Type t = exprType.getType();
    	    if (!t.canAssignTo(returnType)){
    	    	throw new TypecheckerException(n.getReturn(), "return type mismatch"+"  t is "+t+" returnType is "+returnType);
    	    }
            MOVE moveNode = new MOVE(typechecker.currentMethod.hidden.access.exp(new TEMP(typechecker.currentMethod.frame.FP())),exprType.expr.unEx() );
            JUMP jumpNode = new JUMP(typechecker.currentMethod.exitLabel);
            SEQ seqNode = new SEQ(moveNode, jumpNode);
            
        	return seqNode;
        }n.getSemi(); // yields TSemi
        
        if(returnType!=Type.voidType){
        	throw new TypecheckerException(n.getReturn(), "return type mismatch"+"  t is void  returnType is "+returnType);
        }

        return new JUMP(typechecker.currentMethod.exitLabel);
    }

    ///////////////////////////////////////////////////////////////
    Stm process(APrintStmt n) {
    	//System.out.println("in APrintStmt");
        Token t = n.getPrint();				// yields TPrint
        n.getLparen();				// yields TLparen
        ExprType e = process(n.getExpr());			// process(PExpr)
        n.getRparen();				// yields TRparen
        n.getSemi();				// yields TSemi
	
	if (e.getType().toString().equals("void")  ){
			throw new TypecheckerException (t, "Cannot print void! ");
		} 
	ESTM eStm = new ESTM(new CALL(new NAME(typechecker.builtins.printString), new ExpList(e.expr.unEx())));
	return eStm;
    }

    ///////////////////////////////////////////////////////////////
    Stm process(AEmptyStmt n) {
    	//System.out.println("in AEmptyStmt");
        n.getSemi();				// yields TSemi
        return typechecker.noop();
    }

   

    /////////////////////////////////////////////////////////////// done
    ExprType process(PExpr n) {
        if (n instanceof AAssignExpr) return process((AAssignExpr)n);
	else if (n instanceof AExprExpr) return process((AExprExpr)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PExpr)");

      
    }

    ///////////////////////////////////////////////////////////////done
    ExprType process(AAssignExpr n) {
        ExprType a = process(n.getLhs());			// process(PLhs)
        Token t = n.getAssign();				// yields TAssign
        ExprType b = process(n.getExpr());			// process(PExpr)
		if (!b.getType().canAssignTo(a.getType())){
				
			throw new TypecheckerException(t, "incompatible types: "+b.getType()+" cannot be converted to "+a.getType());
		}
		Temp temp = new Temp();
		MOVE leftNode = new MOVE(new TEMP(temp), b.expr.unEx());
		MOVE rightNode = new MOVE(a.expr.unEx(), new TEMP(temp));
		SEQ seqNode = new SEQ(leftNode, rightNode);
		ESEQ eSeq= new ESEQ(seqNode, new TEMP(temp));
		
		
		return new ExprType (new Ex(eSeq), a.getType());
       
    }

    ///////////////////////////////////////////////////////////////done
    ExprType process(AExprExpr n) {
        return process(n.getExpr10());			// process(PExpr10)
             
    }

    ///////////////////////////////////////////////////////////////done
    ExprType process(PExpr10 n) {
        if (n instanceof AOrExpr10) return process((AOrExpr10)n);
	else if (n instanceof AExprExpr10) return process((AExprExpr10)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PExpr10)");

        
    }

    ///////////////////////////////////////////////////////////////done
    ExprType process(AOrExpr10 n) {
        ExprType a = process(n.getLeft());			// process(PExpr10)
        Token t = n.getOr();				// yields TOr
        ExprType b = process(n.getRight());			// process(PExpr20)
		if (!a.getType().toString().equals("boolean") || !b.getType().toString().equals("boolean")){
			throw new TypecheckerException (t, "Bad operand types for binary operator '||'");
		}
			
		return new ExprType(new CxRel(t, a.expr, b.expr), Type.booleanType);
    }

    ///////////////////////////////////////////////////////////////done
    ExprType process(AExprExpr10 n) {
        return process(n.getExpr20());			// process(PExpr20)

        
    }

    ///////////////////////////////////////////////////////////////done
    ExprType process(PExpr20 n) {
        if (n instanceof AAndExpr20) return process((AAndExpr20)n);
	else if (n instanceof AExprExpr20) return process((AExprExpr20)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PExpr20)");

        
    }

    ///////////////////////////////////////////////////////////////done
    ExprType process(AAndExpr20 n) {
        ExprType a = process(n.getLeft());			// process(PExpr20)
        Token t = n.getAnd();				// yields TAnd
        ExprType b = process(n.getRight());			// process(PExpr30)
	
		if (!a.getType().toString().equals("boolean") || !b.getType().toString().equals("boolean")){
			throw new TypecheckerException (t, "Bad operand types for binary operator '&&'");
		}
		return new ExprType(new CxRel(t, a.expr, b.expr), Type.booleanType);
	
        
    }

    ///////////////////////////////////////////////////////////////done
    ExprType process(AExprExpr20 n) {
        return process(n.getExpr30());			// process(PExpr30)

        
    }

    ///////////////////////////////////////////////////////////////done
    ExprType process (PExpr30 n) {
        if (n instanceof AEqExpr30) return process((AEqExpr30)n);
	else if (n instanceof ANeExpr30) return process((ANeExpr30)n);
	else if (n instanceof AExprExpr30) return process((AExprExpr30)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PExpr30)");

        
    }

    ///////////////////////////////////////////////////////////////done
    ExprType process(AEqExpr30 n) {
        ExprType a = process(n.getLeft());			// process(PLhs)
        Token t = n.getEq();				// yields TAssign
        ExprType b = process(n.getRight());			// process(PExpr)
		if (!a.getType().sameType(b.getType())){
		//this is not redundant, because void always returns no to canAssignto, but void types can be compared.
			if(!a.getType().canAssignTo(b.getType()) && !b.getType().canAssignTo(a.getType())){ 
				throw new TypecheckerException(t, "Types are incomparable");
			}
		}
	
		return new ExprType(new CxRel(t, a.expr, b.expr), Type.booleanType);
    }

    ///////////////////////////////////////////////////////////////done
    ExprType process(ANeExpr30 n) {
        ExprType a = process(n.getLeft());			// process(PLhs)
        Token t = n.getNe();				// yields TAssign
        ExprType b = process(n.getRight());			// process(PExpr)
		if (!a.getType().canAssignTo(b.getType())){
			//this is not redundant, because void always returns no to canAssignto, but void types can be compared.
			if(!a.getType().canAssignTo(b.getType()) && !b.getType().canAssignTo(a.getType())){ 
			throw new TypecheckerException(t, "Types are incomparable");
			}
		}
		return new ExprType(new CxRel(t, a.expr, b.expr), Type.booleanType);
    }

    ///////////////////////////////////////////////////////////////done
    ExprType process(AExprExpr30 n) {
        return process(n.getExpr40());			// process(PExpr40)

        
    }

    ///////////////////////////////////////////////////////////////done
    ExprType process(PExpr40 n) {
        if (n instanceof ALtExpr40) return process((ALtExpr40)n);
	else if (n instanceof ALeExpr40) return process((ALeExpr40)n);
	else if (n instanceof AGeExpr40) return process((AGeExpr40)n);
	else if (n instanceof AGtExpr40) return process((AGtExpr40)n);
	else if (n instanceof AExprExpr40) return process((AExprExpr40)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PExpr40)");

       
    }

    ///////////////////////////////////////////////////////////////done
    ExprType process(ALtExpr40 n) {
        ExprType a = process(n.getLeft());			// process(PExpr40)
        Token t = n.getLt();				// yields TLt
        ExprType b = process(n.getRight());			// process(PExpr50)
	
	if (!a.getType().toString().equals("int") || !b.getType().toString().equals("int")){
		throw new TypecheckerException (t, "Bad operand types for binary operator '<'");
	}
	return new ExprType(new CxRel(t, a.expr, b.expr), Type.booleanType);
	
        

    }

    ///////////////////////////////////////////////////////////////done
    ExprType process(ALeExpr40 n) {
        ExprType a = process(n.getLeft());			// process(PExpr40)
        Token t = n.getLe();				// yields TLt
        ExprType b = process(n.getRight());			// process(PExpr50)
	
	if (!a.getType().toString().equals("int") || !b.getType().toString().equals("int")){
		throw new TypecheckerException (t, "Bad operand types for binary operator '<='");
	}
	return new ExprType(new CxRel(t, a.expr, b.expr), Type.booleanType);
    }

    ///////////////////////////////////////////////////////////////done
    ExprType process(AGeExpr40 n) {
        ExprType a = process(n.getLeft());			// process(PExpr40)
        Token t = n.getGe();				// yields TLt
        ExprType b = process(n.getRight());			// process(PExpr50)
	
	if (!a.getType().toString().equals("int") || !b.getType().toString().equals("int")){
		throw new TypecheckerException (t, "Bad operand types for binary operator '>='");
	}
	return new ExprType(new CxRel(t, a.expr, b.expr), Type.booleanType);
    }

    ///////////////////////////////////////////////////////////////done
    ExprType process(AGtExpr40 n) {
        ExprType a = process(n.getLeft());			// process(PExpr40)
        Token t = n.getGt();				// yields TLt
        ExprType b = process(n.getRight());			// process(PExpr50)
	
	if (!a.getType().toString().equals("int") || !b.getType().toString().equals("int")){
		throw new TypecheckerException (t, "Bad operand types for binary operator '>'");
	}
	return new ExprType(new CxRel(t, a.expr, b.expr), Type.booleanType);
    }

    ///////////////////////////////////////////////////////////////done
    ExprType process(AExprExpr40 n) {
        return process(n.getExpr50());			// process(PExpr50)

        
    }

    ///////////////////////////////////////////////////////////////done
    ExprType process(PExpr50 n) {
        if (n instanceof APlusExpr50) return process((APlusExpr50)n);
	else if (n instanceof AMinusExpr50) return process((AMinusExpr50)n);
	else if (n instanceof ATermExpr50) return process((ATermExpr50)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PExpr50)");

        
    }

    ///////////////////////////////////////////////////////////////done
    ExprType process(APlusExpr50 n) {
        ExprType a = process(n.getLeft());			// process(PExpr50)
        Token t = n.getPlus();				// yields TPlus
        ExprType b = process(n.getRight());			// process(PTerm)
        Type aType = a.getType();
        Type bType = b.getType();

        if ((aType.sameType(Type.intType) && bType.sameType(Type.intType))){
        	return new ExprType(new Ex(new BINOP(0, a.expr.unEx(), b.expr.unEx())), Type.intType);
        }
        else if (aType.sameType(Type.stringType) && bType.sameType(Type.intType)){ 
			NAME intToString = new NAME (typechecker.builtins.intToString);
			CALL intCall = new CALL (intToString, new ExpList(b.expr.unEx()));
			NAME stringConcatenate = new NAME (typechecker.builtins.stringConcatenate);
			CALL catCall = new CALL (stringConcatenate, new ExpList(a.expr.unEx(), intCall));
			return new ExprType(new Ex(catCall), Type.stringType);	
		}
        else if (aType.sameType(Type.intType)&&bType.sameType(Type.stringType)){
				NAME intToString = new NAME (typechecker.builtins.intToString);
				CALL intCall = new CALL (intToString, new ExpList(a.expr.unEx()));
				NAME stringConcatenate = new NAME (typechecker.builtins.stringConcatenate);
				CALL catCall = new CALL (stringConcatenate, new ExpList(intCall, b.expr.unEx()));
				return new ExprType(new Ex(catCall), Type.stringType);
				
		}else if (aType.sameType(Type.stringType) && bType.sameType(Type.stringType)){
			NAME stringConcatenate = new NAME (typechecker.builtins.stringConcatenate);
			CALL catCall = new CALL (stringConcatenate, new ExpList(a.expr.unEx(), b.expr.unEx()));
			return new ExprType(new Ex(catCall), Type.stringType);
		}else if(aType.sameType(Type.stringType)){
			if(bType.sameType(Type.booleanType)||bType.sameType(Type.nullType)){
				throw new TypecheckerException (t, "In this program, bad operand types for binary operator '+'");
			}
		}else if(bType.sameType(Type.stringType)){
			if(aType.sameType(Type.booleanType)||aType.sameType(Type.nullType)){
				throw new TypecheckerException (t, "In this program, bad operand types for binary operator '+'");
			}
		}

		throw new TypecheckerException (t, "Bad operand types for binary operator '+'");
    }

    ///////////////////////////////////////////////////////////////done
    ExprType process(AMinusExpr50 n) {
        ExprType a = process(n.getLeft());			// process(PExpr50)
        Token t = n.getMinus();				// yields TMinus
        ExprType b = process(n.getRight());			// process(PTerm)

        if (!a.getType().toString().equals("int") || !b.getType().toString().equals("int")){
		throw new TypecheckerException (t, "Bad operand types for binary operator '-'");
	}
        return new ExprType(new Ex(new BINOP(1, a.expr.unEx(), b.expr.unEx())), a.getType());
    }

    ///////////////////////////////////////////////////////////////done
    ExprType process(ATermExpr50 n) {
    
        return process(n.getTerm());			// process(PTerm)

        
    }

    ///////////////////////////////////////////////////////////////done
    ExprType process(PTerm n) {
        
	if (n instanceof ATimesTerm) return process((ATimesTerm)n);
	else if (n instanceof ADivTerm) return process((ADivTerm)n);
	else if (n instanceof AModTerm) return process((AModTerm)n);
	else if (n instanceof AFactorTerm) return process((AFactorTerm)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PTerm)");       
    }

    ///////////////////////////////////////////////////////////////done
    ExprType process(ATimesTerm n) {
        ExprType a = process(n.getLeft());			// process(PTerm)
        Token t = n.getTimes();				// yields TTimes
        ExprType b = process(n.getRight());			// process(PFactor)
	
	if (!a.getType().toString().equals("int") || !b.getType().toString().equals("int")){
		throw new TypecheckerException (t, "Bad operand types for binary operator '*'");
	}
	return new ExprType(new Ex(new BINOP(2, a.expr.unEx(), b.expr.unEx())), a.getType());
        
    }

    ///////////////////////////////////////////////////////////////done
    ExprType process(ADivTerm n) {
        ExprType a = process(n.getLeft());			// process(PTerm)
        Token t = n.getDiv();				// yields TDiv
        ExprType b = process (n.getRight());			// process(PFactor)

        if (!a.getType().toString().equals("int") || !b.getType().toString().equals("int")){
		throw new TypecheckerException (t, "Bad operand types for binary operator '/'");
	}
        return new ExprType(new Ex(new BINOP(3, a.expr.unEx(), b.expr.unEx())), Type.intType);
    }

    ///////////////////////////////////////////////////////////////done
    ExprType process(AModTerm n) {
        ExprType left = process(n.getLeft());			// process(PTerm)
        Token t = n.getMod();				// yields TMod
        ExprType right = process(n.getRight());			// process(PFactor)
	 if (!left.getType().toString().equals("int") || !right.getType().toString().equals("int")){
		throw new TypecheckerException (t, "Bad operand types for binary operator '%'");
	}
        return new ExprType(new Ex(new BINOP(10, left.expr.unEx(), right.expr.unEx())), Type.intType);
    }

    ///////////////////////////////////////////////////////////////done
    ExprType process(AFactorTerm n) {
        return process(n.getFactor());			// process(PFactor)
    }

    ///////////////////////////////////////////////////////////////done
    ExprType process(PFactor n) {        
	if (n instanceof APrimaryFactor) return process((APrimaryFactor)n);
	else if (n instanceof AIdFactor) return process((AIdFactor)n);
	else if (n instanceof ALengthFactor) return process((ALengthFactor)n);
	else if (n instanceof ALength2Factor) return process((ALength2Factor)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PFactor)");
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(APrimaryFactor n) {
        return process(n.getPrimary());			// process(PPrimary)
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AIdFactor n) {
        n.getId();				// yields TId
		//System.out.println("an id factor "+n.getId());
        Var result = typechecker.lookup(n.getId().getText(), n.getId());
        return new ExprType(typechecker.varExpr(result), result.type);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ALengthFactor n) {
        Token t = n.getId();				// yields TId
        n.getDot();				// yields TDot
        Var v= typechecker.lookup(t.getText(), t);
	
		if (v.type.primitive()){
			throw new TypecheckerException (t, v.type.toString() + " has no .length variable");
		}    
		Exp leftNode = typechecker.varExp(v);    
	    BINOP binopNode = new BINOP(1, leftNode, new CONST(typechecker.machine.wordSize()));
	    MEM memNode = new MEM(binopNode);
    
	    return new ExprType (new Ex(memNode), Type.intType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ALength2Factor n) {
        Token t = n.getId();				// yields TId
        n.getDot();				// yields TDot
        n.getLength();				// yields TLength
        n.getLparen();				// yields TLparen
        n.getRparen();				// yields TRparen
        Var v= typechecker.lookup(n.getId().getText(), n.getId());
		
	if (!v.type.toString().equals("String") ){
		throw new TypecheckerException (t, v.type.toString() + " has no length() method");
	}
	
		NAME nameNode = new NAME (typechecker.builtins.stringLength);		
		CALL callNode = new CALL (nameNode, new ExpList(typechecker.varExp(v)));		
		
		return new ExprType (new Ex(callNode), Type.intType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(PPrimary n) {
        if (n instanceof ANewarrayPrimary) return process((ANewarrayPrimary)n);
	else if (n instanceof APrimary2Primary) return process((APrimary2Primary)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PPrimary)");

    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ANewarrayPrimary n) {
        n.getNew();				// yields TNew
        n.getId();				// yields TId
        n.getLbrack();				// yields TLbrack
        ExprType expr=process(n.getExpr());			// process(PExpr)
        if(!expr.getType().sameType(Type.intType))
        	throw new TypecheckerException(n.getLbrack(), "incompatible types: "+expr.getType()+" cannot be converted to int");
        n.getRbrack();				// yields TRbrack
        Type nType = typechecker.getType(n.getId());  //n.getID() yields TId
        Type array = new ArrayType(nType);
		for (PEmptydim p : n.getEmptydim()){
			array = typechecker.makeArrayType(array, n.getId());
			//process(p);				// process(PEmptydim)
		}
		//Create Actual Array Type
		
		NAME nameNode = new NAME (typechecker.builtins.createArray);
		ExpList x = new ExpList (expr.expr.unEx());
		CALL callNode = new CALL(nameNode, x);
			
        return new ExprType(new Ex(callNode), array);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(APrimary2Primary n) {
   
        return process(n.getPrimary2());			// process(PPrimary2)
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(PPrimary2 n) {
        if (n instanceof AIconstPrimary2) return process((AIconstPrimary2)n);
	else if (n instanceof ASconstPrimary2) return process((ASconstPrimary2)n);
	else if (n instanceof ANullPrimary2) return process((ANullPrimary2)n);
	else if (n instanceof ATruePrimary2) return process((ATruePrimary2)n);
	else if (n instanceof AFalsePrimary2) return process((AFalsePrimary2)n);
	else if (n instanceof AParensPrimary2) return process((AParensPrimary2)n);
	else if (n instanceof ACallPrimary2) return process((ACallPrimary2)n);
	else if (n instanceof AArrayrefPrimary2) return process((AArrayrefPrimary2)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PPrimary2)");
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AIconstPrimary2 n) {
        Integer.parseInt(n.getIconst().getText());				// yields TIconst       
        
        return new ExprType(new Ex( new CONST (Integer.parseInt(n.getIconst().getText()))), Type.intType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ASconstPrimary2 n) {
        String sconst = n.getSconst().getText();				// yields TSconst
        if(!typechecker.stringMap.containsKey(sconst)){
        	typechecker.stringMap.put(sconst, new Label());
        }
        return new ExprType(new Ex (new NAME(typechecker.stringMap.get(sconst))), Type.stringType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ANullPrimary2 n) {
        n.getNull();				// yields TNull

        return new ExprType(new Ex(new CONST(0)), Type.nullType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ATruePrimary2 n) {
        n.getTrue();				// yields TTrue

        return new ExprType(new Ex(new CONST(1)), Type.booleanType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AFalsePrimary2 n) {
        n.getFalse();				// yields TFalse

        return new ExprType(new Ex(new CONST(0)), Type.booleanType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AParensPrimary2 n) {
        n.getLparen();				// yields TLparen
        return process(n.getExpr());			// process(PExpr)
        //n.getRparen();				// yields TRparen
    }

    /////////////////////////////////////////////////////////////// 
    ExprType process(ACallPrimary2 n) {
        n.getId();				// yields TId     
        n.getLparen();				// yields TLparen
        List<ExprType> l = new LinkedList<ExprType>();
        if (n.getArglist() != null){
        	l = process(n.getArglist());		// process(PArglist)
        }
        n.getRparen();				// yields TRparen
        List <Type> typelist = new LinkedList<Type>();
        ExpList expList = new ExpList();
        for (ExprType expr: l){
        	typelist.add(expr.getType());
        	expList.addLast(expr.expr.unEx());
        }
        String name = n.getId().getText();
        Method m = new Method (name, typelist);
        //Label label = typechecker.machine.makeLabel("m_"+ name);
        //m.setLabel(label);
        
        
        Method definedMethod=null;
        Type returnType = null;
        int count=0;
        for (Method method: typechecker.getMethodList()){
        	if(m.equals(method)){ 
        		definedMethod=method;
        		if(count==1){
        			throw new TypecheckerException(n.getId(), "ambiguous: multiple methods match");
        		}
        		returnType = method.getReturnType();
        		count=1;
        	}
        }
        if(count==0){
		
        	throw new TypecheckerException(n.getId(), "No matching method found"); 
        }
        return new ExprType(new Ex(new CALL(new NAME(definedMethod.label), expList)), returnType);
        
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AArrayrefPrimary2 n) {
        return process(n.getArrayref());			// process(PArrayref)
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(PArrayref n) {
        if (n instanceof ANameArrayref) return process((ANameArrayref)n);
	else if (n instanceof APrimaryArrayref) return process((APrimaryArrayref)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PArrayref)");
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ANameArrayref n) {
    	Var arrayRef = typechecker.lookup(n.getId().getText(), n.getId());			// yields TId
        n.getLbrack();				// yields TLbrack
        ExprType expression = process(n.getExpr());			// process(PExpr)
        if(!expression.getType().sameType(Type.intType))
        	throw new TypecheckerException(n.getId(), expression.getType()+" cannot be converted to int");
        n.getRbrack();				// yields TRbrack

        ArrayType arrayType;
        Type arrayRefType = arrayRef.type;
        
        if(arrayRefType instanceof ArrayType)
        	arrayType = (ArrayType) arrayRefType;
        else
        	throw new TypecheckerException(n.getId(), "array required, but "+arrayRefType+" found");
        Exp index = new BINOP("MUL", new CONST(typechecker.machine.wordSize()), expression.expr.unEx());
        Exp pointer = typechecker.varExp(arrayRef);
        return new ExprType(new Ex(new MEM(new BINOP("PLUS", index, pointer))), arrayType.getBaseType());
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(APrimaryArrayref n) {
        ExprType base=process(n.getPrimary2());			// process(PPrimary2)
        ArrayType arrayType = (ArrayType) base.getType();
        
        n.getLbrack();				// yields TLbrack
        ExprType expression = process(n.getExpr());			// process(PExpr)
        n.getRbrack();				// yields TRbrack
        
        
        Exp leftNode = base.expr.unEx();
        BINOP rightNode = new BINOP("MUL", expression.expr.unEx(), new CONST(typechecker.machine.wordSize()));
        BINOP binopNode = new BINOP("PLUS", leftNode, rightNode);
        MEM memNode = new MEM(binopNode);
        
        return new ExprType(new Ex(memNode), arrayType.getBaseType());
    }

    ///////////////////////////////////////////////////////////////done
    ExprType process(PLhs n) {
        if (n instanceof AIdLhs) return process((AIdLhs)n);
	else if (n instanceof AArrayrefLhs) return process((AArrayrefLhs)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PLhs)");
    }

    ///////////////////////////////////////////////////////////////done
    ExprType process(AIdLhs n) {
        Var v = typechecker.lookup(n.getId().getText(), n.getId());
        
        return new ExprType(typechecker.varExpr(v), v.type);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AArrayrefLhs n) {
        return process(n.getArrayref());			// process(PArrayref)
    }

    ///////////////////////////////////////////////////////////////
    List<ExprType> process(PArglist n) {
        if (n instanceof AListArglist) return process((AListArglist)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PArglist)");

    }

    ///////////////////////////////////////////////////////////////
    List<ExprType> process(AListArglist n) {
    	LinkedList<ExprType> l = new LinkedList<ExprType>();
        ExprType expression =process(n.getExpr());			// process(PExpr)
        l.add(expression);
        for (PArg p : n.getArg())
        	l.add(process(p));				// process(PArg)

        return l;     
    }

    ///////////////////////////////////////////////////////////////done
    ExprType process(PArg n) {
        if (n instanceof AArg) return process((AArg)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PArg)");

       
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AArg n) {
        n.getComma();				// yields TComma
        return process(n.getExpr());			// process(PExpr)
        

    }

    ///////////////////////////////////////////////////////////////done
    void process(PEmptydim n) {
        if (n instanceof AEmptydim) process((AEmptydim)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PEmptydim)");
    }

    ///////////////////////////////////////////////////////////////done
    void process(AEmptydim n) {
        n.getLbrack();				// yields TLbrack
        n.getRbrack();				// yields TRbrack
    }

}

