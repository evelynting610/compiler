/* This file was generated by the Amherst version of SableCC */

package minijava.Typechecker;

import java.util.LinkedList;
import java.util.List;

import minijava.Type.ArrayType;
import minijava.Type.Type;
import minijava.node.*;

public class Phase2
{
	private Typechecker typechecker;
	

	public Phase2(Typechecker t){
		this.typechecker=t;
	}

    void process(Node n) {
    	 throw new RuntimeException(this.getClass() + ": no process method available for " 
	     + n.getClass());
    }

    ///////////////////////////////////////////////////////////////
    void process(Start n) {
         process(n.getPProgram());
    }

    ///////////////////////////////////////////////////////////////
    void process(PProgram n) {
        process((AProgram)n);
    }

    ///////////////////////////////////////////////////////////////
    void process(AProgram n) {
        n.getPublic();				// yields TPublic
        n.getClasstok();				// yields TClasstok
        n.getId();				// yields TId
        n.getLbrace();				// yields TLbrace
	for (PMaindecl p : n.getMaindecl())
	    process(p);				// process(PMaindecl)
        n.getRbrace();				// yields TRbrace
    }

    ///////////////////////////////////////////////////////////////
    void process(PMaindecl n) {
        if (n instanceof AVarMaindecl) process((AVarMaindecl)n);
	else if (n instanceof AMethodMaindecl) process((AMethodMaindecl)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PMaindecl)");
    }

    ///////////////////////////////////////////////////////////////
    void process(AVarMaindecl n) {
        process(n.getPrivacy());			// process(PPrivacy)
        n.getStatic();				// yields TStatic
        process(n.getType());			// process(PType)
        n.getId();				// yields TId
        n.getSemi();				// yields TSemi
    }

    ///////////////////////////////////////////////////////////////
    void process(AMethodMaindecl n) {
        process(n.getPrivacy());			// process(PPrivacy)
        n.getStatic();				// yields TStatic
        Type nType = process(n.getType());
        n.getId();				// yields TId
        n.getLparen();				// yields TLparen
        typechecker.localSymbolTable.increaseScope();
        process(n.getParamlist());			// process(PParamlist)
        n.getRparen();				// yields TRparen
        n.getLbrace();				// yields TLbrace
		Type t = Type.voidType;
        for (PStmt p : n.getStmt()){
		   t = process(p);	// process(PStmt)
        }
	    if (!t.canAssignTo(nType) && !(t==nType)){
	    	throw new TypecheckerException(n.getId(), "return type mismatch"+"  t is "+t+" nType is "+nType);
	    }
        n.getRbrace();				// yields TRbrace
	    typechecker.localSymbolTable.decreaseScope();
    }

    ///////////////////////////////////////////////////////////////
    List<String> process(PParamlist n) {
        if (n instanceof AListParamlist) return process((AListParamlist)n);
	else if (n instanceof AEmptyParamlist) return process((AEmptyParamlist)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PParamlist)");

    }

    ///////////////////////////////////////////////////////////////
    List<String> process(AListParamlist n) {
		List<String> paramList = new LinkedList<String>();
		String firstParam = n.getId().getText();
		paramList.add(firstParam);
	    Type nType = process(n.getType());
	    Var v = new Var(firstParam, nType);
	    typechecker.declareLocal(firstParam, v, n.getId());
	    for (PParam p : n.getParam()){
	    	Var var = process(p);
	    	String name = var.name;
	    	//System.out.println("Print VarList " + name);
	    	paramList.add(name);				// process(PParam)
	    	typechecker.declareLocal(var.name, var, n.getId());
	    }
    return paramList;
    }

    ///////////////////////////////////////////////////////////////
    List<String> process(AEmptyParamlist n) {
    	return null;
    }

    ///////////////////////////////////////////////////////////////
    Var process(PParam n) {
       return process((AParam)n);
    }

    ///////////////////////////////////////////////////////////////
    Var process(AParam n) {
        n.getComma();				// yields TComma
        Type nType=process(n.getType());			// process(PType)
        Var v = new Var(n.getId().getText(), nType);
        return v;				// yields TId
    }

    ///////////////////////////////////////////////////////////////
    void process(PPrivacy n) {
        if (n instanceof APublicPrivacy) process((APublicPrivacy)n);
	else if (n instanceof ABlankPrivacy) process((ABlankPrivacy)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PPrivacy)");

    }

    ///////////////////////////////////////////////////////////////
    void process(APublicPrivacy n) {
        n.getPublic();				// yields TPublic
    }

    ///////////////////////////////////////////////////////////////
    void process(ABlankPrivacy n) {

    }

    ///////////////////////////////////////////////////////////////
    Type process(PType n) {
        return process((AType)n);
    }

    ///////////////////////////////////////////////////////////////
    Type process(AType n) {
        Type nType = typechecker.getType(n.getId());  //n.getID() yields TId
	for (PEmptydim p : n.getEmptydim()){
		//TESTER CODE:  System.out.println("points to baseCase"+nType);  
		nType = typechecker.makeArrayType(nType, n.getId());
	    //process(p);				// process(PEmptydim)
		}
        return nType;    // remove when method is complete
    }

    ///////////////////////////////////////////////////////////////
    Type process(PStmt n) {
        if (n instanceof AWhileStmt) return process((AWhileStmt)n);
	else if (n instanceof ADeclStmt) return process((ADeclStmt)n);
	else if (n instanceof ABlockStmt) return process((ABlockStmt)n);
	else if (n instanceof AIfStmt) return process((AIfStmt)n);
	else if (n instanceof AExprStmt) return process((AExprStmt)n);
	else if (n instanceof AReturnStmt) return process((AReturnStmt)n);
	else if (n instanceof APrintStmt) return process((APrintStmt)n);
	else if (n instanceof AEmptyStmt) return process((AEmptyStmt)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PStmt)");
    }

    ///////////////////////////////////////////////////////////////
    Type process(AWhileStmt n) {
    	//System.out.println("in while statement");
        Token t = n.getWhile();				// yields TWhile
        n.getLparen();				// yields TLparen
        ExprType expression = process(n.getExpr());			// process(PExpr)
        if(!expression.type.sameType(Type.booleanType))
        	throw new TypecheckerException(n.getLparen(), "incompatible types: "+expression.type+" cannot be converted to boolean");
        n.getRparen();				// yields TRparen
        typechecker.localSymbolTable.increaseScope();
        process(n.getStmt());			// process(PStmt)
        typechecker.localSymbolTable.decreaseScope();
        return Type.voidType;
    }

    ///////////////////////////////////////////////////////////////
    Type process(ADeclStmt n) {
    	//System.out.println("in ADeclStmt");
        Type nType = process(n.getType());			// process(PType)
        String s = n.getId().getText();
        Var v = new Var(s, nType);
        typechecker.declareLocal(s, v, n.getId());
        return nType;
    }

    ///////////////////////////////////////////////////////////////
    Type process(ABlockStmt n) {
    	//System.out.println("in ABlockStmt");
        n.getLbrace();				// yields TLbrace
        typechecker.localSymbolTable.increaseScope();
        for (PStmt p : n.getStmt())
        	process(p);				// process(PStmt)
        typechecker.localSymbolTable.decreaseScope();
        n.getRbrace();			// yields TRbrace
        return Type.voidType;
    }

    ///////////////////////////////////////////////////////////////
    Type process(AIfStmt n) {
    	//System.out.println("in AIfStmt");
        n.getIf();				// yields TIf
        n.getLparen();				// yields TLparen
        ExprType expression = process(n.getExpr());			// process(PExpr)
        if(!expression.type.sameType(Type.booleanType))
        	throw new TypecheckerException(n.getLparen(), "incompatible types: "+expression.type+" cannot be converted to boolean");
        n.getRparen();				// yields TRparen
        typechecker.localSymbolTable.increaseScope();
        process(n.getThenclause());			// process(PStmt)
        typechecker.localSymbolTable.decreaseScope();
        n.getElse();				// yields TElse
        typechecker.localSymbolTable.increaseScope();
        Type endOfIfType = process(n.getElseclause());			// process(PStmt)
        typechecker.localSymbolTable.decreaseScope();
        return endOfIfType;
    }

    
    ///////////////////////////////////////////////////////////////
    Type process(AExprStmt n) {
    	//System.out.println("in AExprStmt");
        ExprType e = process(n.getExpr());			// process(PExpr)
        n.getSemi();				// yields TSemi
        return Type.voidType;
        
    }

    ///////////////////////////////////////////////////////////////
    Type process(AReturnStmt n) {
    	//System.out.println("in AReturnStmt");
        n.getReturn();				// yields TReturn
        if (n.getExpr() != null){
            ExprType t = process(n.getExpr());		// process(PExpr)
        	return t.type;
        }n.getSemi(); // yields TSemi
        return Type.voidType;
    }

    ///////////////////////////////////////////////////////////////
    Type process(APrintStmt n) {
    	//System.out.println("in APrintStmt");
        Token t = n.getPrint();				// yields TPrint
        n.getLparen();				// yields TLparen
        ExprType e = process(n.getExpr());			// process(PExpr)
        n.getRparen();				// yields TRparen
        n.getSemi();				// yields TSemi
	
	if (e.type.toString().equals("void")  ){
			throw new TypecheckerException (t, "Cannot print void! ");
		} 
	return Type.voidType;
    }

    ///////////////////////////////////////////////////////////////
    Type process(AEmptyStmt n) {
    	//System.out.println("in AEmptyStmt");
        n.getSemi();				// yields TSemi
        return Type.voidType;
    }

   

    /////////////////////////////////////////////////////////////// done
    ExprType process(PExpr n) {
        if (n instanceof AAssignExpr) return process((AAssignExpr)n);
	else if (n instanceof AExprExpr) return process((AExprExpr)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PExpr)");

      
    }

    ///////////////////////////////////////////////////////////////done
    ExprType process(AAssignExpr n) {
        ExprType a = process(n.getLhs());			// process(PLhs)
        Token t = n.getAssign();				// yields TAssign
        ExprType b = process(n.getExpr());			// process(PExpr)
		if (!b.type.canAssignTo(a.type)){
				
			throw new TypecheckerException(t, "incompatible types: "+b.type+" cannot be converted to "+a.type);
		}
		return new ExprType (null, a.type);
       
    }

    ///////////////////////////////////////////////////////////////done
    ExprType process(AExprExpr n) {
        return process(n.getExpr10());			// process(PExpr10)
             
    }

    ///////////////////////////////////////////////////////////////done
    ExprType process(PExpr10 n) {
        if (n instanceof AOrExpr10) return process((AOrExpr10)n);
	else if (n instanceof AExprExpr10) return process((AExprExpr10)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PExpr10)");

        
    }

    ///////////////////////////////////////////////////////////////done
    ExprType process(AOrExpr10 n) {
        ExprType a = process(n.getLeft());			// process(PExpr10)
        Token t = n.getOr();				// yields TOr
        ExprType b = process(n.getRight());			// process(PExpr20)
		if (!a.type.toString().equals("boolean") || !b.type.toString().equals("boolean")){
			throw new TypecheckerException (t, "Bad operand types for binary operator '||'");
		}
			
        return new ExprType(null, Type.booleanType);
    }

    ///////////////////////////////////////////////////////////////done
    ExprType process(AExprExpr10 n) {
        return process(n.getExpr20());			// process(PExpr20)

        
    }

    ///////////////////////////////////////////////////////////////done
    ExprType process(PExpr20 n) {
        if (n instanceof AAndExpr20) return process((AAndExpr20)n);
	else if (n instanceof AExprExpr20) return process((AExprExpr20)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PExpr20)");

        
    }

    ///////////////////////////////////////////////////////////////done
    ExprType process(AAndExpr20 n) {
        ExprType a = process(n.getLeft());			// process(PExpr20)
        Token t = n.getAnd();				// yields TAnd
        ExprType b = process(n.getRight());			// process(PExpr30)
	
		if (!a.type.toString().equals("boolean") || !b.type.toString().equals("boolean")){
			throw new TypecheckerException (t, "Bad operand types for binary operator '&&'");
		}
	return new ExprType(null, Type.booleanType);
	
        
    }

    ///////////////////////////////////////////////////////////////done
    ExprType process(AExprExpr20 n) {
        return process(n.getExpr30());			// process(PExpr30)

        
    }

    ///////////////////////////////////////////////////////////////done
    ExprType process (PExpr30 n) {
        if (n instanceof AEqExpr30) return process((AEqExpr30)n);
	else if (n instanceof ANeExpr30) return process((ANeExpr30)n);
	else if (n instanceof AExprExpr30) return process((AExprExpr30)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PExpr30)");

        
    }

    ///////////////////////////////////////////////////////////////done
    ExprType process(AEqExpr30 n) {
        ExprType a = process(n.getLeft());			// process(PLhs)
        Token t = n.getEq();				// yields TAssign
        ExprType b = process(n.getRight());			// process(PExpr)
		if (!a.type.sameType(b.type)){
		//this is not redundant, because void always returns no to canAssignto, but void types can be compared.
			if(!a.type.canAssignTo(b.type) && !b.type.canAssignTo(a.type)){ 
				throw new TypecheckerException(t, "Types are incomparable");
			}
		}
	
		return new ExprType(null, Type.booleanType);
    }

    ///////////////////////////////////////////////////////////////done
    ExprType process(ANeExpr30 n) {
        ExprType a = process(n.getLeft());			// process(PLhs)
        Token t = n.getNe();				// yields TAssign
        ExprType b = process(n.getRight());			// process(PExpr)
		if (!a.type.canAssignTo(b.type)){
			//this is not redundant, because void always returns no to canAssignto, but void types can be compared.
			if(!a.type.canAssignTo(b.type) && !b.type.canAssignTo(a.type)){ 
			throw new TypecheckerException(t, "Types are incomparable");
			}
		}
		return new ExprType(null, Type.booleanType);
    }

    ///////////////////////////////////////////////////////////////done
    ExprType process(AExprExpr30 n) {
        return process(n.getExpr40());			// process(PExpr40)

        
    }

    ///////////////////////////////////////////////////////////////done
    ExprType process(PExpr40 n) {
        if (n instanceof ALtExpr40) return process((ALtExpr40)n);
	else if (n instanceof ALeExpr40) return process((ALeExpr40)n);
	else if (n instanceof AGeExpr40) return process((AGeExpr40)n);
	else if (n instanceof AGtExpr40) return process((AGtExpr40)n);
	else if (n instanceof AExprExpr40) return process((AExprExpr40)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PExpr40)");

       
    }

    ///////////////////////////////////////////////////////////////done
    ExprType process(ALtExpr40 n) {
        ExprType a = process(n.getLeft());			// process(PExpr40)
        Token t = n.getLt();				// yields TLt
        ExprType b = process(n.getRight());			// process(PExpr50)
	
	if (!a.type.toString().equals("int") || !b.type.toString().equals("int")){
		throw new TypecheckerException (t, "Bad operand types for binary operator '<'");
	}
	return new ExprType(null, Type.booleanType);
	
        

    }

    ///////////////////////////////////////////////////////////////done
    ExprType process(ALeExpr40 n) {
        ExprType a = process(n.getLeft());			// process(PExpr40)
        Token t = n.getLe();				// yields TLt
        ExprType b = process(n.getRight());			// process(PExpr50)
	
	if (!a.type.toString().equals("int") || !b.type.toString().equals("int")){
		throw new TypecheckerException (t, "Bad operand types for binary operator '<='");
	}
	return new ExprType(null, Type.booleanType);
    }

    ///////////////////////////////////////////////////////////////done
    ExprType process(AGeExpr40 n) {
        ExprType a = process(n.getLeft());			// process(PExpr40)
        Token t = n.getGe();				// yields TLt
        ExprType b = process(n.getRight());			// process(PExpr50)
	
	if (!a.type.toString().equals("int") || !b.type.toString().equals("int")){
		throw new TypecheckerException (t, "Bad operand types for binary operator '>='");
	}
	return new ExprType(null, Type.booleanType);
    }

    ///////////////////////////////////////////////////////////////done
    ExprType process(AGtExpr40 n) {
        ExprType a = process(n.getLeft());			// process(PExpr40)
        Token t = n.getGt();				// yields TLt
        ExprType b = process(n.getRight());			// process(PExpr50)
	
	if (!a.type.toString().equals("int") || !b.type.toString().equals("int")){
		throw new TypecheckerException (t, "Bad operand types for binary operator '>'");
	}
	return new ExprType(null, Type.booleanType);
    }

    ///////////////////////////////////////////////////////////////done
    ExprType process(AExprExpr40 n) {
        return process(n.getExpr50());			// process(PExpr50)

        
    }

    ///////////////////////////////////////////////////////////////done
    ExprType process(PExpr50 n) {
        if (n instanceof APlusExpr50) return process((APlusExpr50)n);
	else if (n instanceof AMinusExpr50) return process((AMinusExpr50)n);
	else if (n instanceof ATermExpr50) return process((ATermExpr50)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PExpr50)");

        
    }

    ///////////////////////////////////////////////////////////////done
    ExprType process(APlusExpr50 n) {
        ExprType a = process(n.getLeft());			// process(PExpr50)
        Token t = n.getPlus();				// yields TPlus
        ExprType b = process(n.getRight());			// process(PTerm)
        Type helper = Type.intType;
		if (!(a.type.toString().equals("int") && b.type.toString().equals("int"))){
			helper = Type.stringType;
			if ((!a.type.toString().equals("String")&&!b.type.toString().equals("String")) || a.type.toString().equals("void") || b.type.toString().equals("void"))  //Can you add void or null to string?
				throw new TypecheckerException (t, "Bad operand types for binary operator '+'");
		}
	
	
		return new ExprType(null, helper);
    }

    ///////////////////////////////////////////////////////////////done
    ExprType process(AMinusExpr50 n) {
        ExprType a = process(n.getLeft());			// process(PExpr50)
        Token t = n.getMinus();				// yields TMinus
        ExprType b = process(n.getRight());			// process(PTerm)

        if (!a.type.toString().equals("int") || !b.type.toString().equals("int")){
		throw new TypecheckerException (t, "Bad operand types for binary operator '-'");
	}
        return new ExprType(null, a.type);
    }

    ///////////////////////////////////////////////////////////////done
    ExprType process(ATermExpr50 n) {
    
        return process(n.getTerm());			// process(PTerm)

        
    }

    ///////////////////////////////////////////////////////////////done
    ExprType process(PTerm n) {
        
	if (n instanceof ATimesTerm) return process((ATimesTerm)n);
	else if (n instanceof ADivTerm) return process((ADivTerm)n);
	else if (n instanceof AModTerm) return process((AModTerm)n);
	else if (n instanceof AFactorTerm) return process((AFactorTerm)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PTerm)");       
    }

    ///////////////////////////////////////////////////////////////done
    ExprType process(ATimesTerm n) {
        ExprType a = process(n.getLeft());			// process(PTerm)
        Token t = n.getTimes();				// yields TTimes
        ExprType b = process(n.getRight());			// process(PFactor)
	
	if (!a.type.toString().equals("int") || !b.type.toString().equals("int")){
		throw new TypecheckerException (t, "Bad operand types for binary operator '*'");
	}
		return new ExprType(null, a.type);
        
    }

    ///////////////////////////////////////////////////////////////done
    ExprType process(ADivTerm n) {
        ExprType a = process(n.getLeft());			// process(PTerm)
        Token t = n.getDiv();				// yields TDiv
        ExprType b = process (n.getRight());			// process(PFactor)

        if (!a.type.toString().equals("int") || !b.type.toString().equals("int")){
		throw new TypecheckerException (t, "Bad operand types for binary operator '/'");
	}
        return new ExprType(null, Type.intType);
    }

    ///////////////////////////////////////////////////////////////done
    ExprType process(AModTerm n) {
        ExprType a = process(n.getLeft());			// process(PTerm)
        Token t = n.getMod();				// yields TMod
        ExprType b = process(n.getRight());			// process(PFactor)
	 if (!a.type.toString().equals("int") || !b.type.toString().equals("int")){
		throw new TypecheckerException (t, "Bad operand types for binary operator '%'");
	}
        return new ExprType(null, Type.intType);
    }

    ///////////////////////////////////////////////////////////////done
    ExprType process(AFactorTerm n) {
        return process(n.getFactor());			// process(PFactor)
    }

    ///////////////////////////////////////////////////////////////done
    ExprType process(PFactor n) {        
	if (n instanceof APrimaryFactor) return process((APrimaryFactor)n);
	else if (n instanceof AIdFactor) return process((AIdFactor)n);
	else if (n instanceof ALengthFactor) return process((ALengthFactor)n);
	else if (n instanceof ALength2Factor) return process((ALength2Factor)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PFactor)");
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(APrimaryFactor n) {
        return process(n.getPrimary());			// process(PPrimary)
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AIdFactor n) {
        n.getId();				// yields TId
		//System.out.println("an id factor "+n.getId());
        Var result = typechecker.lookup(n.getId().getText(), n.getId());

        return new ExprType(null, result.type);
OBOA    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ALengthFactor n) {
        Token t = n.getId();				// yields TId
        n.getDot();				// yields TDot
	Var v= typechecker.lookup(n.getId().getText(), n.getId());
	
	if (v.type.primitive()){
		throw new TypecheckerException (t, v.type.toString() + " has no .length variable");
	}       
	
	
        return new ExprType (null, Type.intType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ALength2Factor n) {
        Token t = n.getId();				// yields TId
        n.getDot();				// yields TDot
        n.getLength();				// yields TLength
        n.getLparen();				// yields TLparen
        n.getRparen();				// yields TRparen
	Var v= typechecker.lookup(n.getId().getText(), n.getId());
		
	if (!v.type.toString().equals("String") ){
		throw new TypecheckerException (t, v.type.toString() + " has no length() method");
	}

        return new ExprType (null, Type.intType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(PPrimary n) {
        if (n instanceof ANewarrayPrimary) return process((ANewarrayPrimary)n);
	else if (n instanceof APrimary2Primary) return process((APrimary2Primary)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PPrimary)");

    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ANewarrayPrimary n) {
        n.getNew();				// yields TNew
        n.getId();				// yields TId
        n.getLbrack();				// yields TLbrack
        ExprType expr=process(n.getExpr());			// process(PExpr)
        if(!expr.type.sameType(Type.intType))
        	throw new TypecheckerException(n.getLbrack(), "incompatible types: "+expr.type+" cannot be converted to int");
        n.getRbrack();				// yields TRbrack
        Type nType = typechecker.getType(n.getId());  //n.getID() yields TId
        Type array = new ArrayType(nType);
		for (PEmptydim p : n.getEmptydim()){
			array = typechecker.makeArrayType(array, n.getId());
			//process(p);				// process(PEmptydim)
		}
		//Create Actual Array Type
        return new ExprType(null, array);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(APrimary2Primary n) {
   
        return process(n.getPrimary2());			// process(PPrimary2)
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(PPrimary2 n) {
        if (n instanceof AIconstPrimary2) return process((AIconstPrimary2)n);
	else if (n instanceof ASconstPrimary2) return process((ASconstPrimary2)n);
	else if (n instanceof ANullPrimary2) return process((ANullPrimary2)n);
	else if (n instanceof ATruePrimary2) return process((ATruePrimary2)n);
	else if (n instanceof AFalsePrimary2) return process((AFalsePrimary2)n);
	else if (n instanceof AParensPrimary2) return process((AParensPrimary2)n);
	else if (n instanceof ACallPrimary2) return process((ACallPrimary2)n);
	else if (n instanceof AArrayrefPrimary2) return process((AArrayrefPrimary2)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PPrimary2)");
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AIconstPrimary2 n) {
        n.getIconst();				// yields TIconst
        
        return new ExprType(null, Type.intType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ASconstPrimary2 n) {
        n.getSconst();				// yields TSconst
        
        return new ExprType(null, Type.stringType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ANullPrimary2 n) {
        n.getNull();				// yields TNull

        return new ExprType(null, Type.nullType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ATruePrimary2 n) {
        n.getTrue();				// yields TTrue

        return new ExprType(null, Type.booleanType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AFalsePrimary2 n) {
        n.getFalse();				// yields TFalse

        return new ExprType(null, Type.booleanType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AParensPrimary2 n) {
        n.getLparen();				// yields TLparen
        return process(n.getExpr());			// process(PExpr)
        //n.getRparen();				// yields TRparen
    }

    /////////////////////////////////////////////////////////////// 
    ExprType process(ACallPrimary2 n) {
        n.getId();				// yields TId     
        n.getLparen();				// yields TLparen
        List<ExprType> l = new LinkedList<ExprType>();
        if (n.getArglist() != null){
        	l = process(n.getArglist());		// process(PArglist)
        }
        n.getRparen();				// yields TRparen
        List <Type> typelist = new LinkedList<Type>();
        for (ExprType expr: l){
        	typelist.add(expr.type);
        }
        Method m = new Method (n.getId().getText(), typelist);
        Type returnType = null;
        int count=0;
        for (Method method: typechecker.getMethodList()){
        	if(m.equals(method)){ 
        		if(count==1){
        			throw new TypecheckerException(n.getId(), "ambiguous: multiple methods match");
        		}
        		returnType = method.getReturnType();
        		count=1;
        	}
        }
        if(count==0){
		
        	throw new TypecheckerException(n.getId(), "No matching method found"); 
        }
        
        return new ExprType(null, returnType);
        
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AArrayrefPrimary2 n) {
        return process(n.getArrayref());			// process(PArrayref)
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(PArrayref n) {
        if (n instanceof ANameArrayref) return process((ANameArrayref)n);
	else if (n instanceof APrimaryArrayref) return process((APrimaryArrayref)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PArrayref)");
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ANameArrayref n) {
    	Var arrayRef = typechecker.lookup(n.getId().getText(), n.getId());			// yields TId
        n.getLbrack();				// yields TLbrack
        ExprType expression = process(n.getExpr());			// process(PExpr)
        if(!expression.type.sameType(Type.intType))
        	throw new TypecheckerException(n.getId(), expression.type+" cannot be converted to int");
        n.getRbrack();				// yields TRbrack

        ArrayType arrayType;
        Type arrayRefType = arrayRef.type;
        
        if(arrayRefType instanceof ArrayType)
        	arrayType = (ArrayType) arrayRefType;
        else
        	throw new TypecheckerException(n.getId(), "array required, but "+arrayRefType+" found");
       
        return new ExprType(null, arrayType.getBaseType());
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(APrimaryArrayref n) {
        ExprType base=process(n.getPrimary2());			// process(PPrimary2)
        ArrayType arrayType = (ArrayType) base.type;
        n.getLbrack();				// yields TLbrack
        ExprType expression = process(n.getExpr());			// process(PExpr)
        n.getRbrack();				// yields TRbrack
        return new ExprType(null, arrayType.getBaseType());
    }

    ///////////////////////////////////////////////////////////////done
    ExprType process(PLhs n) {
        if (n instanceof AIdLhs) return process((AIdLhs)n);
	else if (n instanceof AArrayrefLhs) return process((AArrayrefLhs)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PLhs)");
    }

    ///////////////////////////////////////////////////////////////done
    ExprType process(AIdLhs n) {
        Var v = typechecker.lookup(n.getId().getText(), n.getId());
        return new ExprType(null, v.type);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AArrayrefLhs n) {
        return process(n.getArrayref());			// process(PArrayref)
    }

    ///////////////////////////////////////////////////////////////
    List<ExprType> process(PArglist n) {
        if (n instanceof AListArglist) return process((AListArglist)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PArglist)");

    }

    ///////////////////////////////////////////////////////////////
    List<ExprType> process(AListArglist n) {
    	LinkedList<ExprType> l = new LinkedList<ExprType>();
        ExprType expression =process(n.getExpr());			// process(PExpr)
        l.add(expression);
        for (PArg p : n.getArg())
        	l.add(process(p));				// process(PArg)

        return l;     
    }

    ///////////////////////////////////////////////////////////////done
    ExprType process(PArg n) {
        if (n instanceof AArg) return process((AArg)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PArg)");

       
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AArg n) {
        n.getComma();				// yields TComma
        return process(n.getExpr());			// process(PExpr)
        

    }

    ///////////////////////////////////////////////////////////////done
    void process(PEmptydim n) {
        if (n instanceof AEmptydim) process((AEmptydim)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PEmptydim)");
    }

    ///////////////////////////////////////////////////////////////done
    void process(AEmptydim n) {
        n.getLbrack();				// yields TLbrack
        n.getRbrack();				// yields TRbrack
    }

}

